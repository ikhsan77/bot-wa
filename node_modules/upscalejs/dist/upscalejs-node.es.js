var b=Object.defineProperty;var x=(r,t,s)=>t in r?b(r,t,{enumerable:!0,configurable:!0,writable:!0,value:s}):r[t]=s;var n=(r,t,s)=>(x(r,typeof t!="symbol"?t+"":t,s),s);import{d as A,c as D}from"./options.js";import v,{createImageData as I,createCanvas as U}from"canvas";import*as C from"onnxruntime-node";class L{constructor(t,s){n(this,"ort");n(this,"baseURL");n(this,"models",new Map);this.ort=t,this.baseURL=s}async loadModel(t){const s=this.models.get(t);if(s)return s;this.ort.env.wasm.wasmPaths=`${this.baseURL}js/`;const o=`${this.baseURL}models/up2x-latest-${t}.onnx`,a=this.ort.InferenceSession.create(o);return this.models.set(t,a),a}async predict(t,s){var p;const o=new Array,a=new Array,c=new Array;for(let e=0;e<t.data.length;e+=4)o.push(t.data[e]),a.push(t.data[e+1]),c.push(t.data[e+2]);const i=o.concat(a).concat(c),d=new Float32Array(3*200*200);for(let e=0;e<d.length;e++)d[e]=i[e]/255;const m=new this.ort.Tensor("float32",d,[1,3,200,200]),g=await this.loadModel(s),f={input_1:m},w=await g.run(f),l=new Uint8ClampedArray(4*400*400),y=w.output_1.data;for(const e of Array(4).keys())for(let u=16e4*e,h=e;h<l.length;u++,h+=4)l[h]=(p=y[u])!=null?p:255;return I(l,400,400)}}class _{constructor(t){n(this,"options");n(this,"predictor");this.options=Object.assign(A,t),this.predictor=new L(C,this.options.base)}async upscale(t){const s=U(t.width*2,t.height*2),o=D(t);for(let a=0;a<o.length;a++){const c=o[a].element.getContext("2d").getImageData(0,0,200,200),i=await this.predictor.predict(c,this.options.denoiseModel);s.getContext("2d").putImageData(i,o[a].x,o[a].y)}return s.getContext("2d").getImageData(0,0,s.width,s.height)}}module.exports={Upscaler:_,canvas:v};export{_ as Upscaler};
